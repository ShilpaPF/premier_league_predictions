#Import necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.impute import SimpleImputer
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.model_selection import GridSearchCV
import warnings
warnings.filterwarnings('ignore')
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

# Load the dataset
file_path = "/content/drive/MyDrive/Premier_League_Data.csv"
df = pd.read_csv(file_path)

# Create a mapping from numeric codes to actual team names
team_mapping = dict(enumerate(df['Team'].unique()))

# Convert Date to datetime
df['Date'] = pd.to_datetime(df['Date'], format='%d-%m-%Y')

# Feature engineering
df['Day_of_Week'] = df['Date'].dt.dayofweek
df['Month'] = df['Date'].dt.month
df['Year'] = df['Date'].dt.year
df['Goal_Difference'] = df['Goals For'] - df['Goals Against']
df['Goal_Ratio'] = df['Goals For'] / (df['Goals Against'] + 1)  # Add 1 to avoid division by zero
df['Shot_Accuracy'] = df['Shots on Target'] / df['Shots']
df['Expected_Goal_Difference'] = df['Expected Goals'] - df['Expected Goals Against']
# Display basic information about the dataset
print(df.info())
print(df.describe())

# Check for missing values
print(df.isnull().sum()

#Select features for clustering
cluster_features = ['Goals For', 'Goals Against', 'Expected Goals', 'Expected Goals Against', 'Possession', 'Shots', 'Shots on Target']

# Prepare data for clustering
X_cluster = df[cluster_features]

# Standardize the features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_cluster)

# Perform K-means clustering
kmeans = KMeans(n_clusters=3, random_state=42)
df['Cluster'] = kmeans.fit_predict(X_scaled)

# Visualize the clusters
plt.figure(figsize=(12, 8))
scatter = plt.scatter(df['Expected Goals'], df['Expected Goals Against'], c=df['Cluster'], cmap='viridis')
plt.xlabel('Expected Goals')
plt.ylabel('Expected Goals Against')
plt.title('Team Clusters based on Expected Goals')
plt.colorbar(scatter)
plt.show()

# Print cluster centroids
centroids = scaler.inverse_transform(kmeans.cluster_centers_)
centroid_df = pd.DataFrame(centroids, columns=cluster_features)
print("Cluster Centroids:")
print(centroid_df)

# Analyze clusters
for i in range(3):
    print(f"\nCluster {i}:")
    print(df[df['Cluster'] == i]['Team'].value_counts())
    print(df[df['Cluster'] == i][cluster_features].mean())

# Convert categorical variables to numeric
le = LabelEncoder()
categorical_cols = ['Team', 'Opponent', 'Venue', 'Result', 'Captain', 'Formation', 'Referee', 'Competition', 'Round', 'Day']
for col in categorical_cols:
    df[col] = le.fit_transform(df[col].astype(str))

# Map team numbers back to names
df['Team'] = df['Team'].map(team_mapping)

# Remove outliers using IQR method
def remove_outliers(df, columns):
    for col in columns:
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        df = df[(df[col] >= lower_bound) & (df[col] <= upper_bound)]
    return df

numeric_columns = ['Goals For', 'Goals Against', 'Expected Goals', 'Expected Goals Against', 'Possession', 'Shots', 'Shots on Target']

print("Shape before removing outliers:", df.shape)
df = remove_outliers(df, numeric_columns)
print("Shape after removing outliers:", df.shape)

# Display all column names and their data types
print("All columns and their data types:")
print(df.dtypes)

# Identify numeric columns
numeric_cols = df.select_dtypes(include=[np.number]).columns
print("\nNumeric columns found:", numeric_cols.tolist())

# Calculate average goals scored by each team
team_avg_goals = df.groupby('Team')['Goals For'].mean().sort_values(ascending=False)
# Select top 10 scoring teams
top_10_teams = team_avg_goals.head(10).index
